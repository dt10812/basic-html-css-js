<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blockchain Demo</title>
    <style>
        :root {
            --primary: #6d28d9;
            --primary-hover: #5b21b6;
            --secondary: #1f2937;
            --background: #f9fafb;
            --foreground: #111827;
            --muted: #e5e7eb;
            --muted-foreground: #6b7280;
            --border: #e5e7eb;
            --card: #ffffff;
            --card-foreground: #111827;
            --success: #10b981;
            --error: #ef4444;
            --radius: 0.5rem;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --background: #111827;
                --foreground: #f9fafb;
                --muted: #1f2937;
                --muted-foreground: #9ca3af;
                --border: #374151;
                --card: #1f2937;
                --card-foreground: #f9fafb;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        body {
            background-color: var(--background);
            color: var(--foreground);
            line-height: 1.5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        header {
            border-bottom: 1px solid var(--border);
            padding: 1rem 0;
            position: sticky;
            top: 0;
            background-color: var(--background);
            z-index: 10;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: bold;
            font-size: 1.25rem;
        }

        .logo-icon {
            width: 2rem;
            height: 2rem;
            border-radius: 9999px;
            background: linear-gradient(to bottom right, #8b5cf6, #06b6d4);
        }

        .tabs {
            display: flex;
            margin: 1.5rem 0;
            background-color: var(--muted);
            border-radius: var(--radius);
            padding: 0.25rem;
        }

        .tab {
            flex: 1;
            text-align: center;
            padding: 0.75rem;
            cursor: pointer;
            border-radius: calc(var(--radius) - 0.25rem);
            font-weight: 500;
            color: var(--muted-foreground);
        }

        .tab.active {
            background-color: var(--card);
            color: var(--foreground);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .card {
            background-color: var(--card);
            border-radius: var(--radius);
            border: 1px solid var(--border);
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .card-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .card-description {
            color: var(--muted-foreground);
            font-size: 0.875rem;
        }

        .card-content {
            padding: 1rem;
        }

        .card-footer {
            padding: 1rem;
            border-top: 1px solid var(--border);
        }

        .grid {
            display: grid;
            gap: 1rem;
        }

        @media (min-width: 768px) {
            .grid-cols-2 {
                grid-template-columns: repeat(2, 1fr);
            }

            .grid-cols-3 {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .form-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
        }

        textarea, input, select {
            width: 100%;
            padding: 0.5rem;
            border-radius: calc(var(--radius) - 0.25rem);
            border: 1px solid var(--border);
            background-color: var(--background);
            color: var(--foreground);
            font-size: 0.875rem;
        }

        textarea {
            min-height: 100px;
            resize: vertical;
        }

        button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: calc(var(--radius) - 0.25rem);
            font-weight: 500;
            font-size: 0.875rem;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            border: none;
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: var(--primary-hover);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-full {
            width: 100%;
        }

        .progress-container {
            margin-top: 1rem;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
        }

        .progress {
            height: 0.5rem;
            background-color: var(--muted);
            border-radius: 9999px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--primary);
            transition: width 0.2s;
        }

        .stats-card {
            padding: 1rem;
        }

        .stats-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-top: 0.25rem;
        }

        .stats-label {
            font-size: 0.75rem;
            color: var(--muted-foreground);
        }

        .block {
            border-left: 4px solid var(--success);
            margin-bottom: 1rem;
        }

        .block.invalid {
            border-left-color: var(--error);
        }

        .block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
        }

        .block-title {
            font-size: 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            border-radius: 9999px;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        .badge-success {
            background-color: var(--success);
            color: white;
        }

        .badge-error {
            background-color: var(--error);
            color: white;
        }

        .block-timestamp {
            font-size: 0.75rem;
            color: var(--muted-foreground);
        }

        .block-content {
            padding: 1rem;
        }

        .block-row {
            display: grid;
            grid-template-columns: 1fr 2fr;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }

        .block-label {
            font-weight: 500;
        }

        .block-value {
            font-family: monospace;
            word-break: break-all;
            font-size: 0.75rem;
        }

        .block-data {
            margin-top: 0.5rem;
        }

        .block-data-label {
            font-weight: 500;
            margin-bottom: 0.25rem;
            font-size: 0.875rem;
        }

        .block-data-value {
            background-color: var(--muted);
            padding: 0.5rem;
            border-radius: calc(var(--radius) - 0.25rem);
            font-family: monospace;
            font-size: 0.75rem;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .space-y-4 > * + * {
            margin-top: 1rem;
        }

        .list {
            list-style-position: inside;
            padding-left: 1rem;
        }

        .list > li {
            margin-bottom: 0.5rem;
        }

        .note {
            background-color: var(--muted);
            padding: 1rem;
            border-radius: var(--radius);
            margin-top: 1rem;
            font-size: 0.875rem;
        }

        .note-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        footer {
            border-top: 1px solid var(--border);
            padding: 1.5rem 0;
            margin-top: 2rem;
        }

        .footer-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            text-align: center;
            color: var(--muted-foreground);
            font-size: 0.875rem;
        }

        @media (min-width: 768px) {
            .footer-content {
                flex-direction: row;
                justify-content: space-between;
                text-align: left;
            }
        }

        .flex {
            display: flex;
        }

        .items-center {
            align-items: center;
        }

        .justify-between {
            justify-content: space-between;
        }

        .gap-2 {
            gap: 0.5rem;
        }

        .text-xs {
            font-size: 0.75rem;
        }

        .font-mono {
            font-family: monospace;
        }

        .truncate {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .animate-spin {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        .memory-slider-container {
            margin-top: 0.5rem;
        }

        .memory-slider {
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .memory-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            color: var(--muted-foreground);
        }

        .memory-usage-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.75rem;
        }

        .memory-usage-current {
            font-weight: bold;
        }

        .warning {
            color: var(--error);
            font-size: 0.75rem;
            margin-top: 0.5rem;
        }

        .wallet-card {
            background-color: var(--card);
            border-radius: var(--radius);
            border: 1px solid var(--border);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .wallet-balance {
            font-size: 2rem;
            font-weight: bold;
            margin: 0.5rem 0;
        }

        .wallet-address {
            font-family: monospace;
            font-size: 0.75rem;
            background-color: var(--muted);
            padding: 0.5rem;
            border-radius: calc(var(--radius) - 0.25rem);
            word-break: break-all;
        }

        .transaction-form {
            margin-top: 1rem;
        }

        .transaction-code {
            font-family: monospace;
            font-size: 0.75rem;
            background-color: var(--muted);
            padding: 0.5rem;
            border-radius: calc(var(--radius) - 0.25rem);
            word-break: break-all;
            margin-top: 0.5rem;
        }

        .transaction-history {
            margin-top: 1rem;
        }

        .transaction-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
        }

        .transaction-amount {
            font-weight: bold;
        }

        .transaction-amount.positive {
            color: var(--success);
        }

        .transaction-amount.negative {
            color: var(--error);
        }

        .transaction-date {
            font-size: 0.75rem;
            color: var(--muted-foreground);
        }

        .copy-button {
            background-color: var(--muted);
            color: var(--foreground);
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            margin-left: 0.5rem;
            cursor: pointer;
        }

        .copy-button:hover {
            background-color: var(--border);
        }

        .success-message {
            color: var(--success);
            font-size: 0.875rem;
            margin-top: 0.5rem;
        }

        .error-message {
            color: var(--error);
            font-size: 0.875rem;
            margin-top: 0.5rem;
        }

        .contract-info {
            margin-top: 1rem;
            border-top: 1px solid var(--border);
            padding-top: 1rem;
        }

        .contract-address {
            font-family: monospace;
            font-size: 0.75rem;
            background-color: var(--muted);
            padding: 0.5rem;
            border-radius: calc(var(--radius) - 0.25rem);
            word-break: break-all;
            margin-top: 0.5rem;
        }

        .contract-label {
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .contract-icon {
            width: 1.25rem;
            height: 1.25rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <div class="logo-icon"></div>
                    <span>Blockchain Demo</span>
                </div>
            </div>
        </div>
    </header>

    <main class="container">
        <div class="tabs">
            <div class="tab active" data-tab="mine">Mine Blocks</div>
            <div class="tab" data-tab="blockchain">View Blockchain</div>
            <div class="tab" data-tab="wallet">Wallet</div>
        </div>

        <div class="tab-content active" id="mine-tab">
            <div class="grid grid-cols-2">
                <div class="space-y-4">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Mine a New Block</h2>
                            <p class="card-description">Add data to your block and start mining to add it to the blockchain</p>
                        </div>
                        <div class="card-content">
                            <div class="form-group">
                                <label for="block-data">Block Data</label>
                                <textarea id="block-data" placeholder="Enter data for your block...">My block data</textarea>
                            </div>
                            <div class="form-group">
                                <label for="memory-usage">Memory Usage</label>
                                <div class="memory-slider-container">
                                    <input type="range" id="memory-slider" class="memory-slider" min="100" max="32000" step="100" value="1000">
                                    <div class="memory-display">
                                        <span>100 MB</span>
                                        <span id="memory-value">1000 MB (1 GB)</span>
                                        <span>32 GB</span>
                                    </div>
                                    <div class="memory-usage-stats">
                                        <span>Current Usage: <span id="current-memory-usage" class="memory-usage-current">0 MB</span></span>
                                        <span>Target: <span id="target-memory-usage" class="memory-usage-current">1000 MB</span></span>
                                    </div>
                                    <div id="memory-warning" class="warning" style="display: none;">
                                        Warning: Very high memory usage may cause browser instability or crashes.
                                    </div>
                                </div>
                            </div>
                            <div id="mining-progress" class="progress-container" style="display: none;">
                                <div class="progress-header">
                                    <span>Mining Progress</span>
                                    <span id="progress-percentage">0%</span>
                                </div>
                                <div class="progress">
                                    <div class="progress-bar" style="width: 0%"></div>
                                </div>
                            </div>
                        </div>
                        <div class="card-footer">
                            <button id="mine-button" class="btn-primary btn-full">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.5rem;">
                                    <path d="m13 9 2 2 4-4"></path>
                                    <path d="M12 22a9 9 0 1 0 0-18 9 9 0 0 0 0 18Z"></path>
                                </svg>
                                Start Mining
                            </button>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Mining Rewards</h2>
                            <p class="card-description">Educational demonstration of mining rewards</p>
                        </div>
                        <div class="card-content">
                            <div class="space-y-4">
                                <div class="flex items-center justify-between">
                                    <span class="text-sm font-medium">Blocks Mined:</span>
                                    <span class="font-mono" id="blocks-mined">0</span>
                                </div>
                                <div class="flex items-center justify-between">
                                    <span class="text-sm font-medium">EncrCoins Earned:</span>
                                    <span class="font-mono" id="tokens-earned">0.0000000</span>
                                </div>
                                <div class="flex items-center justify-between">
                                    <span class="text-sm font-medium">Last Block Mined:</span>
                                    <span class="font-mono" id="last-block-time">Never</span>
                                </div>
                                <div class="text-xs" style="color: var(--muted-foreground); margin-top: 1rem;">
                                    Note: This is for educational purposes only. No real cryptocurrency is being mined.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="space-y-4">
                    <div class="grid grid-cols-3">
                        <div class="card stats-card">
                            <div class="card-title" style="font-size: 0.875rem;">Blocks Mined</div>
                            <div class="stats-value" id="stats-blocks">0</div>
                            <div class="stats-label">Total blocks added to the chain</div>
                        </div>

                        <div class="card stats-card">
                            <div class="card-title" style="font-size: 0.875rem;">Hash Rate</div>
                            <div class="stats-value" id="stats-hashrate">0</div>
                            <div class="stats-label">Hashes per second</div>
                        </div>

                        <div class="card stats-card">
                            <div class="card-title" style="font-size: 0.875rem;">Total Hashes</div>
                            <div class="stats-value" id="stats-total-hashes">0</div>
                            <div class="stats-label">Total hashes computed</div>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">How Mining Works</h2>
                            <p class="card-description">Educational explanation of blockchain mining</p>
                        </div>
                        <div class="card-content" style="font-size: 0.875rem;">
                            <p>Mining is the process of adding new blocks to a blockchain by solving a computational puzzle.</p>
                            <ol class="list" style="margin-top: 1rem;">
                                <li>
                                    <strong>The Challenge:</strong> Find a hash that starts with "000" by trying different nonce values.
                                </li>
                                <li>
                                    <strong>Proof of Work:</strong> The computer must perform many calculations to find a valid hash.
                                </li>
                                <li>
                                    <strong>Validation:</strong> Once found, the block is added to the chain and linked to the previous
                                    block.
                                </li>
                                <li>
                                    <strong>Reward:</strong> In real blockchains, miners receive cryptocurrency as a reward.
                                </li>
                            </ol>
                            <p style="margin-top: 1rem;">
                                This demo simulates the mining process in your browser to demonstrate how blockchain technology works.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="tab-content" id="blockchain-tab">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Blockchain Explorer</h2>
                    <p class="card-description">View all blocks in the blockchain and their details</p>
                </div>
                <div class="card-content">
                    <div id="blockchain-container" class="space-y-4">
                        <p style="text-align: center; color: var(--muted-foreground); padding: 2rem 0;">
                            No blocks in the blockchain yet. Start mining!
                        </p>
                    </div>
                </div>
            </div>

            <div class="card" style="margin-top: 1.5rem;">
                <div class="card-header">
                    <h2 class="card-title">About This Demo</h2>
                    <p class="card-description">Educational information about blockchain technology</p>
                </div>
                <div class="card-content" style="font-size: 0.875rem;">
                    <p>This is a simplified educational demonstration of how blockchain technology works. It shows:</p>
                    <ul class="list" style="margin-top: 1rem;">
                        <li>How blocks are chained together using cryptographic hashes</li>
                        <li>The proof-of-work concept through mining (finding a hash with leading zeros)</li>
                        <li>How changing data in one block would invalidate all subsequent blocks</li>
                        <li>The computational effort required to mine blocks</li>
                    </ul>
                    <div class="note">
                        <p class="note-title">Important Note:</p>
                        <p>
                            This is for educational purposes only and is not a real cryptocurrency. No actual tokens of value are
                            being created or transferred.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <div class="tab-content" id="wallet-tab">
            <div class="grid grid-cols-2">
                <div class="space-y-4">
                    <div class="wallet-card">
                        <h2 class="card-title">Your EncrCoin Wallet</h2>
                        <p class="card-description">Your current balance and wallet address</p>
                        <div class="wallet-balance" id="wallet-balance">0.0000000</div>
                        <p class="text-xs">EncrCoins</p>
                        <div class="wallet-address" id="wallet-address">Generating wallet address...</div>
                        
                        <div class="contract-info">
                            <div class="contract-label">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="contract-icon">
                                    <path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"></path>
                                </svg>
                                EncrCoin Contract Address
                            </div>
                            <div class="contract-address" id="contract-address">0x7a58c0be72be218b41c608b7fe7c5bb630736c71</div>
                            <button id="copy-contract-button" class="copy-button" style="margin-top: 0.5rem;">Copy Contract Address</button>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Send EncrCoins</h2>
                            <p class="card-description">Generate a transaction code to send EncrCoins</p>
                        </div>
                        <div class="card-content">
                            <div class="transaction-form">
                                <div class="form-group">
                                    <label for="send-amount">Amount to Send</label>
                                    <input type="number" id="send-amount" min="0.0000001" step="0.0000001" placeholder="0.0000001">
                                </div>
                                <button id="generate-code-button" class="btn-primary btn-full">Generate Transaction Code</button>
                                <div id="transaction-code-container" style="display: none;">
                                    <p style="margin-top: 1rem; font-weight: 500;">Transaction Code:</p>
                                    <div class="transaction-code" id="transaction-code"></div>
                                    <div style="display: flex; justify-content: flex-end; margin-top: 0.5rem;">
                                        <button id="copy-code-button" class="copy-button">Copy Code</button>
                                    </div>
                                </div>
                                <div id="send-message" class="success-message" style="display: none;"></div>
                            </div>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Redeem EncrCoins</h2>
                            <p class="card-description">Enter a transaction code to receive EncrCoins</p>
                        </div>
                        <div class="card-content">
                            <div class="transaction-form">
                                <div class="form-group">
                                    <label for="redeem-code">Transaction Code</label>
                                    <input type="text" id="redeem-code" placeholder="Enter transaction code">
                                </div>
                                <button id="redeem-code-button" class="btn-primary btn-full">Redeem EncrCoins</button>
                                <div id="redeem-message" class="success-message" style="display: none;"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="space-y-4">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Transaction History</h2>
                            <p class="card-description">Your recent EncrCoin transactions</p>
                        </div>
                        <div class="card-content">
                            <div id="transaction-history" class="transaction-history">
                                <p style="text-align: center; color: var(--muted-foreground); padding: 1rem 0;">
                                    No transactions yet.
                                </p>
                            </div>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">About EncrCoin Transactions</h2>
                            <p class="card-description">How EncrCoin transactions work</p>
                        </div>
                        <div class="card-content" style="font-size: 0.875rem;">
                            <p>EncrCoin uses AES-256 encryption for secure transactions:</p>
                            <ol class="list" style="margin-top: 1rem;">
                                <li>
                                    <strong>Generate a Code:</strong> When you send EncrCoins, the system generates an encrypted code.
                                </li>
                                <li>
                                    <strong>Share the Code:</strong> Give this code to the recipient (or use it yourself).
                                </li>
                                <li>
                                    <strong>Redeem EncrCoins:</strong> The recipient enters the code to receive the EncrCoins.
                                </li>
                                <li>
                                    <strong>One-time Use:</strong> Each code can only be used once.
                                </li>
                            </ol>
                            <div class="note" style="margin-top: 1rem;">
                                <p class="note-title">Security Note:</p>
                                <p>
                                    This uses AES-256 encryption in CBC mode with PKCS5 padding. For educational purposes only.
                                </p>
                            </div>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">About Contract Address</h2>
                            <p class="card-description">Understanding the EncrCoin contract</p>
                        </div>
                        <div class="card-content" style="font-size: 0.875rem;">
                            <p>In blockchain technology, a contract address is a unique identifier for a smart contract:</p>
                            <ul class="list" style="margin-top: 1rem;">
                                <li>
                                    <strong>Smart Contract:</strong> A self-executing contract with the terms directly written into code.
                                </li>
                                <li>
                                    <strong>Contract Address:</strong> The unique location on the blockchain where the token's code resides.
                                </li>
                                <li>
                                    <strong>Token Standard:</strong> EncrCoin follows a standard similar to ERC-20 tokens on Ethereum.
                                </li>
                                <li>
                                    <strong>Verification:</strong> The contract address allows users to verify the authenticity of the token.
                                </li>
                            </ul>
                            <div class="note" style="margin-top: 1rem;">
                                <p class="note-title">Educational Note:</p>
                                <p>
                                    This contract address is for demonstration purposes only and does not exist on any real blockchain.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <p>&copy; <span id="current-year"></span> Blockchain Demo. Educational purposes only.</p>
                <p>This is not a real cryptocurrency.</p>
            </div>
        </div>
    </footer>

    <script>
        // Set current year in footer
        document.getElementById('current-year').textContent = new Date().getFullYear();

        // Tab switching
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.getAttribute('data-tab');
                
                // Update active tab
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Update active content
                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(`${tabId}-tab`).classList.add('active');
            });
        });

        // Memory usage slider
        const memorySlider = document.getElementById('memory-slider');
        const memoryValue = document.getElementById('memory-value');
        const targetMemoryUsage = document.getElementById('target-memory-usage');
        const currentMemoryUsage = document.getElementById('current-memory-usage');
        const memoryWarning = document.getElementById('memory-warning');
        
        // Memory buffers to maintain the desired memory usage
        let memoryBuffers = [];
        let targetMemoryMB = parseInt(memorySlider.value);
        
        // Update memory value display when slider changes
        memorySlider.addEventListener('input', () => {
            const value = parseInt(memorySlider.value);
            targetMemoryMB = value;
            
            let displayValue = '';
            if (value >= 1000) {
                displayValue = `${value} MB (${(value / 1000).toFixed(1)} GB)`;
            } else {
                displayValue = `${value} MB`;
            }
            
            memoryValue.textContent = displayValue;
            targetMemoryUsage.textContent = `${value} MB`;
            
            // Show warning for high memory values
            if (value > 8000) {
                memoryWarning.style.display = 'block';
            } else {
                memoryWarning.style.display = 'none';
            }
        });

        // Function to allocate memory
        function allocateMemory(targetMB) {
            try {
                // Clear existing buffers
                memoryBuffers = [];
                
                // Calculate how many MB we need to allocate
                const mbToAllocate = targetMB;
                
                // Each buffer will be 100MB
                const bufferSizeMB = 100;
                const numBuffers = Math.floor(mbToAllocate / bufferSizeMB);
                
                // Create buffers of the specified size
                for (let i = 0; i < numBuffers; i++) {
                    try {
                        // Create a buffer of approximately 100MB (1MB = 1024*1024 bytes)
                        // Each Float64Array element is 8 bytes
                        const bufferSize = Math.floor((bufferSizeMB * 1024 * 1024) / 8);
                        const buffer = new Float64Array(bufferSize);
                        
                        // Fill the buffer with random data to ensure it's actually allocated
                        for (let j = 0; j < buffer.length; j += 1024) {
                            buffer[j] = Math.random();
                        }
                        
                        memoryBuffers.push(buffer);
                    } catch (e) {
                        console.error('Memory allocation failed:', e);
                        break;
                    }
                }
                
                // Update current memory usage display
                updateMemoryUsageDisplay();
                
                return memoryBuffers.length * bufferSizeMB;
            } catch (e) {
                console.error('Memory allocation error:', e);
                return 0;
            }
        }

        // Function to update memory usage display
        function updateMemoryUsageDisplay() {
            // Calculate approximate memory usage
            const usageMB = memoryBuffers.length * 100;
            currentMemoryUsage.textContent = `${usageMB} MB`;
        }

        // Function to get performance settings based on memory usage
        function getPerformanceSettings() {
            // Base settings
            const settings = {
                batchSize: 500,
                reportInterval: 100,
                initialEstimate: 10000
            };
            
            // Scale settings based on allocated memory
            const allocatedMB = memoryBuffers.length * 100;
            
            if (allocatedMB >= 8000) {
                // Ultra high performance for 8GB+
                settings.batchSize = 10000;
                settings.reportInterval = 10;
                settings.initialEstimate = 100000;
            } else if (allocatedMB >= 4000) {
                // Very high performance for 4GB+
                settings.batchSize = 5000;
                settings.reportInterval = 20;
                settings.initialEstimate = 80000;
            } else if (allocatedMB >= 2000) {
                // High performance for 2GB+
                settings.batchSize = 3000;
                settings.reportInterval = 30;
                settings.initialEstimate = 60000;
            } else if (allocatedMB >= 1000) {
                // Good performance for 1GB+
                settings.batchSize = 2000;
                settings.reportInterval = 50;
                settings.initialEstimate = 40000;
            } else if (allocatedMB >= 500) {
                // Medium performance for 500MB+
                settings.batchSize = 1000;
                settings.reportInterval = 75;
                settings.initialEstimate = 20000;
            } else {
                // Base performance for <500MB
                settings.batchSize = 500;
                settings.reportInterval = 100;
                settings.initialEstimate = 10000;
            }
            
            return settings;
        }

        // EncrCoin wallet and transaction functionality
        class EncrCoinWallet {
            constructor() {
                this.balance = 0;
                this.address = this.generateWalletAddress();
                this.transactions = [];
                this.contractAddress = "0x7a58c0be72be218b41c608b7fe7c5bb630736c71";
                this.loadFromCookies();
            }

            generateWalletAddress() {
                // Generate a simple wallet address for demonstration
                const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let address = 'ENCR-';
                for (let i = 0; i < 32; i++) {
                    address += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return address;
            }

            addBalance(amount) {
                this.balance += amount;
                this.saveToCookies();
                this.updateUI();
            }

            deductBalance(amount) {
                if (this.balance >= amount) {
                    this.balance -= amount;
                    this.saveToCookies();
                    this.updateUI();
                    return true;
                }
                return false;
            }

            addTransaction(type, amount, code = null) {
                const transaction = {
                    id: Date.now().toString(36) + Math.random().toString(36).substr(2, 5),
                    type: type,
                    amount: amount,
                    timestamp: Date.now(),
                    code: code
                };
                this.transactions.unshift(transaction);
                
                // Keep only the last 20 transactions
                if (this.transactions.length > 20) {
                    this.transactions = this.transactions.slice(0, 20);
                }
                
                this.saveToCookies();
                this.updateTransactionHistory();
            }

            saveToCookies() {
                const walletData = {
                    balance: this.balance,
                    address: this.address,
                    transactions: this.transactions
                };
                
                // Save wallet data to cookie (expires in 30 days)
                const expiryDate = new Date();
                expiryDate.setDate(expiryDate.getDate() + 30);
                document.cookie = `encrWallet=${JSON.stringify(walletData)};expires=${expiryDate.toUTCString()};path=/`;
            }

            loadFromCookies() {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.startsWith('encrWallet=')) {
                        try {
                            const walletData = JSON.parse(cookie.substring('encrWallet='.length));
                            this.balance = walletData.balance || 0;
                            this.address = walletData.address || this.address;
                            this.transactions = walletData.transactions || [];
                        } catch (e) {
                            console.error('Error parsing wallet data from cookie:', e);
                        }
                        break;
                    }
                }
                this.updateUI();
                this.updateTransactionHistory();
            }

            updateUI() {
                document.getElementById('wallet-balance').textContent = this.balance.toFixed(7);
                document.getElementById('wallet-address').textContent = this.address;
                document.getElementById('tokens-earned').textContent = this.balance.toFixed(7);
                document.getElementById('contract-address').textContent = this.contractAddress;
            }

            updateTransactionHistory() {
                const historyContainer = document.getElementById('transaction-history');
                
                if (this.transactions.length === 0) {
                    historyContainer.innerHTML = `
                        <p style="text-align: center; color: var(--muted-foreground); padding: 1rem 0;">
                            No transactions yet.
                        </p>
                    `;
                    return;
                }
                
                historyContainer.innerHTML = '';
                
                this.transactions.forEach(tx => {
                    const isPositive = tx.type === 'received' || tx.type === 'mined';
                    const formattedDate = new Date(tx.timestamp).toLocaleString();
                    
                    historyContainer.innerHTML += `
                        <div class="transaction-item">
                            <div>
                                <div>${tx.type.charAt(0).toUpperCase() + tx.type.slice(1)}</div>
                                <div class="transaction-date">${formattedDate}</div>
                            </div>
                            <div class="transaction-amount ${isPositive ? 'positive' : 'negative'}">
                                ${isPositive ? '+' : '-'}${tx.amount.toFixed(7)}
                            </div>
                        </div>
                    `;
                });
            }
        }

        // AES-256 Encryption/Decryption
        class EncrCoinCrypto {
            constructor() {
                this.secretKey = "ilvencrcnandisae";
                this.iv = "ilvencrcnandisae";
            }

            // Function to encrypt a message using AES-256
            async encrypt(message) {
                try {
                    // Convert the message to an ArrayBuffer
                    const encoder = new TextEncoder();
                    const data = encoder.encode(message);
                    
                    // Import the key
                    const key = await this.importKey();
                    
                    // Convert IV to ArrayBuffer
                    const ivBuffer = encoder.encode(this.iv);
                    
                    // Encrypt the message
                    const encrypted = await window.crypto.subtle.encrypt(
                        {
                            name: "AES-CBC",
                            iv: ivBuffer
                        },
                        key,
                        data
                    );
                    
                    // Convert the encrypted data to base64
                    return this.arrayBufferToBase64(encrypted);
                } catch (e) {
                    console.error('Encryption error:', e);
                    return null;
                }
            }

            // Function to decrypt a message using AES-256
            async decrypt(encryptedBase64) {
                try {
                    // Convert the base64 to an ArrayBuffer
                    const encryptedData = this.base64ToArrayBuffer(encryptedBase64);
                    
                    // Import the key
                    const key = await this.importKey();
                    
                    // Convert IV to ArrayBuffer
                    const encoder = new TextEncoder();
                    const ivBuffer = encoder.encode(this.iv);
                    
                    // Decrypt the message
                    const decrypted = await window.crypto.subtle.decrypt(
                        {
                            name: "AES-CBC",
                            iv: ivBuffer
                        },
                        key,
                        encryptedData
                    );
                    
                    // Convert the decrypted data to a string
                    const decoder = new TextDecoder();
                    return decoder.decode(decrypted);
                } catch (e) {
                    console.error('Decryption error:', e);
                    return null;
                }
            }

            // Helper function to import the key
            async importKey() {
                const encoder = new TextEncoder();
                const keyData = encoder.encode(this.secretKey);
                
                return await window.crypto.subtle.importKey(
                    "raw",
                    keyData,
                    {
                        name: "AES-CBC",
                        length: 256
                    },
                    false,
                    ["encrypt", "decrypt"]
                );
            }

            // Helper function to convert ArrayBuffer to base64
            arrayBufferToBase64(buffer) {
                const bytes = new Uint8Array(buffer);
                let binary = '';
                for (let i = 0; i < bytes.byteLength; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }

            // Helper function to convert base64 to ArrayBuffer
            base64ToArrayBuffer(base64) {
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }
        }

        // Blockchain implementation
        class Block {
            constructor(index, timestamp, data, previousHash = '') {
                this.index = index;
                this.timestamp = timestamp;
                this.data = data;
                this.previousHash = previousHash;
                this.nonce = 0;
                this.hash = this.calculateHash();
            }

            calculateHash() {
                // Simple hash function for demonstration
                const hashInput = `${this.index}${this.previousHash}${this.timestamp}${this.data}${this.nonce}`;
                let hash = 0;
                for (let i = 0; i < hashInput.length; i++) {
                    const char = hashInput.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                // Convert to hex string and ensure it's positive
                return Math.abs(hash).toString(16).padStart(8, '0');
            }

            mineBlock(difficulty) {
                return new Promise((resolve) => {
                    // Allocate memory before mining
                    const allocatedMB = allocateMemory(targetMemoryMB);
                    console.log(`Allocated approximately ${allocatedMB} MB of memory`);
                    
                    // Get performance settings based on allocated memory
                    const settings = getPerformanceSettings();
                    
                    const worker = new Worker(URL.createObjectURL(new Blob([`
                        // Simple hash function for demonstration
                        function calculateHash(index, previousHash, timestamp, data, nonce) {
                            const hashInput = \`\${index}\${previousHash}\${timestamp}\${data}\${nonce}\`;
                            let hash = 0;
                            for (let i = 0; i < hashInput.length; i++) {
                                const char = hashInput.charCodeAt(i);
                                hash = ((hash << 5) - hash) + char;
                                hash = hash & hash; // Convert to 32bit integer
                            }
                            // Convert to hex string and ensure it's positive
                            return Math.abs(hash).toString(16).padStart(8, '0');
                        }
                        
                        // Check if a hash is valid (has leading zeros)
                        function isValidHash(hash, difficulty) {
                            return hash.startsWith('0'.repeat(difficulty));
                        }
                        
                        onmessage = function(e) {
                            const { index, previousHash, timestamp, data, difficulty, batchSize, reportInterval } = e.data;
                            let nonce = 0;
                            let hash = '';
                            let hashesComputed = 0;
                            const startTime = Date.now();
                            
                            // Process in batches to control memory usage and CPU intensity
                            function processBatch() {
                                for (let i = 0; i < batchSize; i++) {
                                    hash = calculateHash(index, previousHash, timestamp, data, nonce);
                                    hashesComputed++;
                                    
                                    if (isValidHash(hash, difficulty)) {
                                        const endTime = Date.now();
                                        const elapsedSeconds = (endTime - startTime) / 1000;
                                        const hashRate = Math.floor(hashesComputed / elapsedSeconds);
                                        postMessage({ 
                                            type: 'success', 
                                            hash, 
                                            nonce, 
                                            hashesComputed,
                                            hashRate,
                                            elapsedTime: elapsedSeconds
                                        });
                                        return;
                                    }
                                    
                                    nonce++;
                                }
                                
                                // Report progress periodically
                                if (hashesComputed % reportInterval === 0) {
                                    const currentTime = Date.now();
                                    const elapsedSeconds = (currentTime - startTime) / 1000 || 0.001;
                                    const hashRate = Math.floor(hashesComputed / elapsedSeconds);
                                    postMessage({ 
                                        type: 'progress', 
                                        hashRate,
                                        hashesComputed
                                    });
                                }
                                
                                // Schedule next batch with setTimeout to prevent UI freezing
                                setTimeout(processBatch, 0);
                            }
                            
                            // Start processing
                            processBatch();
                        };
                    `], { type: 'application/javascript' })));

                    worker.onmessage = (e) => {
                        const { type, hash, nonce, hashRate, hashesComputed } = e.data;
                        
                        if (type === 'progress') {
                            // Update UI with progress
                            const progress = Math.min(100, Math.floor((hashesComputed / settings.initialEstimate) * 100));
                            document.getElementById('progress-percentage').textContent = `${progress}%`;
                            document.querySelector('.progress-bar').style.width = `${progress}%`;
                            document.getElementById('stats-hashrate').textContent = hashRate.toLocaleString();
                            
                            // Update total hashes
                            const currentTotalHashes = parseInt(document.getElementById('stats-total-hashes').textContent.replace(/,/g, ''));
                            document.getElementById('stats-total-hashes').textContent = (currentTotalHashes + hashesComputed).toLocaleString();
                        } else if (type === 'success') {
                            worker.terminate();
                            this.hash = hash;
                            this.nonce = nonce;
                            
                            // Clear memory buffers after mining is complete
                            memoryBuffers = [];
                            updateMemoryUsageDisplay();
                            
                            resolve({ hash, nonce, hashRate, hashesComputed });
                        }
                    };

                    worker.postMessage({
                        index: this.index,
                        previousHash: this.previousHash,
                        timestamp: this.timestamp,
                        data: this.data,
                        difficulty: difficulty,
                        batchSize: settings.batchSize,
                        reportInterval: settings.reportInterval
                    });
                });
            }
        }

        class Blockchain {
            constructor() {
                this.chain = [this.createGenesisBlock()];
                this.difficulty = 3; // Number of leading zeros required
                this.miningStats = {
                    blocksGenerated: 0,
                    totalHashes: 0,
                    hashRate: 0,
                    startTime: Date.now(),
                    lastBlockTime: 0
                };
            }

            createGenesisBlock() {
                return new Block(0, Date.now(), "Genesis Block - First block in the chain", "0");
            }

            getLatestBlock() {
                return this.chain[this.chain.length - 1];
            }

            async addBlock(newBlock) {
                newBlock.previousHash = this.getLatestBlock().hash;
                
                // Show mining progress
                document.getElementById('mining-progress').style.display = 'block';
                document.getElementById('mine-button').disabled = true;
                document.getElementById('mine-button').innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="animate-spin" style="margin-right: 0.5rem;">
                        <path d="M21 12a9 9 0 1 1-6.219-8.56"></path>
                    </svg>
                    Mining...
                `;
                
                // Mine the block
                const result = await newBlock.mineBlock(this.difficulty);
                
                // Update mining stats
                this.miningStats.blocksGenerated++;
                this.miningStats.totalHashes += result.hashesComputed;
                this.miningStats.hashRate = result.hashRate;
                this.miningStats.lastBlockTime = Date.now();
                
                // Add block to chain
                this.chain.push(newBlock);
                
                // Add mining reward to wallet
                const rewardAmount = 0.0000001;
                wallet.addBalance(rewardAmount);
                wallet.addTransaction('mined', rewardAmount);
                
                // Update UI
                this.updateUI();
                
                // Reset mining UI
                document.getElementById('mining-progress').style.display = 'none';
                document.getElementById('mine-button').disabled = false;
                document.getElementById('mine-button').innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 0.5rem;">
                        <path d="m13 9 2 2 4-4"></path>
                        <path d="M12 22a9 9 0 1 0 0-18 9 9 0 0 0 0 18Z"></path>
                    </svg>
                    Start Mining
                `;
                
                return result;
            }

            isChainValid() {
                for (let i = 1; i < this.chain.length; i++) {
                    const currentBlock = this.chain[i];
                    const previousBlock = this.chain[i - 1];

                    // Check if hash is valid
                    if (!currentBlock.hash.startsWith('0'.repeat(this.difficulty))) {
                        return false;
                    }

                    // Check if hash is correctly calculated
                    if (currentBlock.calculateHash() !== currentBlock.hash) {
                        return false;
                    }

                    // Check if this block points to the correct previous block
                    if (currentBlock.previousHash !== previousBlock.hash) {
                        return false;
                    }
                }
                return true;
            }

            updateUI() {
                // Update mining stats
                document.getElementById('blocks-mined').textContent = this.miningStats.blocksGenerated;
                document.getElementById('last-block-time').textContent = this.miningStats.lastBlockTime ? this.formatTimeAgo(this.miningStats.lastBlockTime) : 'Never';
                
                document.getElementById('stats-blocks').textContent = this.miningStats.blocksGenerated;
                document.getElementById('stats-hashrate').textContent = this.miningStats.hashRate.toLocaleString();
                document.getElementById('stats-total-hashes').textContent = this.miningStats.totalHashes.toLocaleString();
                
                // Update blockchain display
                const blockchainContainer = document.getElementById('blockchain-container');
                blockchainContainer.innerHTML = '';
                
                if (this.chain.length === 0) {
                    blockchainContainer.innerHTML = `
                        <p style="text-align: center; color: var(--muted-foreground); padding: 2rem 0;">
                            No blocks in the blockchain yet. Start mining!
                        </p>
                    `;
                } else {
                    for (let i = this.chain.length - 1; i >= 0; i--) {
                        const block = this.chain[i];
                        const isValid = i === 0 || (block.hash.startsWith('0'.repeat(this.difficulty)) && block.previousHash === this.chain[i-1].hash);
                        
                        blockchainContainer.innerHTML += `
                            <div class="block ${isValid ? '' : 'invalid'}">
                                <div class="block-header">
                                    <div class="block-title">
                                        Block #${block.index}
                                        <span class="badge ${isValid ? 'badge-success' : 'badge-error'}">
                                            ${isValid ? 'Valid' : 'Invalid'}
                                        </span>
                                    </div>
                                    <div class="block-timestamp">${this.formatDate(block.timestamp)}</div>
                                </div>
                                <div class="block-content">
                                    <div class="block-row">
                                        <div class="block-label">Hash:</div>
                                        <div class="block-value">${block.hash}</div>
                                    </div>
                                    <div class="block-row">
                                        <div class="block-label">Previous Hash:</div>
                                        <div class="block-value">${block.previousHash}</div>
                                    </div>
                                    <div class="block-row">
                                        <div class="block-label">Nonce:</div>
                                        <div class="block-value">${block.nonce.toLocaleString()}</div>
                                    </div>
                                    <div class="block-data">
                                        <div class="block-data-label">Data:</div>
                                        <div class="block-data-value">${block.data}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                }
            }
            
            formatDate(timestamp) {
                const date = new Date(timestamp);
                return date.toLocaleString();
            }
            
            formatTimeAgo(timestamp) {
                const seconds = Math.floor((Date.now() - timestamp) / 1000);
                
                if (seconds < 60) return `${seconds} seconds ago`;
                
                const minutes = Math.floor(seconds / 60);
                if (minutes < 60) return `${minutes} minute${minutes !== 1 ? 's' : ''} ago`;
                
                const hours = Math.floor(minutes / 60);
                if (hours < 24) return `${hours} hour${hours !== 1 ? 's' : ''} ago`;
                
                const days = Math.floor(hours / 24);
                return `${days} day${days !== 1 ? 's' : ''} ago`;
            }
        }

        // Initialize blockchain, wallet, and crypto
        const blockchain = new Blockchain();
        const wallet = new EncrCoinWallet();
        const crypto = new EncrCoinCrypto();
        
        // Update UI
        blockchain.updateUI();
        wallet.updateUI();

        // Transaction code storage
        const usedCodes = new Set();

        // Mine button click handler
        document.getElementById('mine-button').addEventListener('click', async () => {
            const blockData = document.getElementByI  async () => {
            const blockData = document.getElementById('block-data').value.trim();
            if (!blockData) return;
            
            const newBlock = new Block(blockchain.chain.length, Date.now(), blockData);
            await blockchain.addBlock(newBlock);
        });

        // Generate transaction code button click handler
        document.getElementById('generate-code-button').addEventListener('click', async () => {
            const amountInput = document.getElementById('send-amount');
            const amount = parseFloat(amountInput.value);
            
            // Validate amount
            if (isNaN(amount) || amount <= 0 || amount > wallet.balance) {
                const sendMessage = document.getElementById('send-message');
                sendMessage.textContent = 'Invalid amount. Please enter a valid amount that you have in your wallet.';
                sendMessage.className = 'error-message';
                sendMessage.style.display = 'block';
                return;
            }
            
            // Deduct from wallet
            if (wallet.deductBalance(amount)) {
                // Generate transaction message
                const message = `Get ${amount.toFixed(7)} EncrCoin`;
                
                // Encrypt the message
                const encryptedCode = await crypto.encrypt(message);
                
                // Display the code
                document.getElementById('transaction-code').textContent = encryptedCode;
                document.getElementById('transaction-code-container').style.display = 'block';
                
                // Add transaction to history
                wallet.addTransaction('sent', amount, encryptedCode);
                
                // Show success message
                const sendMessage = document.getElementById('send-message');
                sendMessage.textContent = `Successfully generated transaction code for ${amount.toFixed(7)} EncrCoins.`;
                sendMessage.className = 'success-message';
                sendMessage.style.display = 'block';
            } else {
                // Show error message
                const sendMessage = document.getElementById('send-message');
                sendMessage.textContent = 'Insufficient balance.';
                sendMessage.className = 'error-message';
                sendMessage.style.display = 'block';
            }
        });

        // Copy code button click handler
        document.getElementById('copy-code-button').addEventListener('click', () => {
            const code = document.getElementById('transaction-code').textContent;
            navigator.clipboard.writeText(code).then(() => {
                const copyButton = document.getElementById('copy-code-button');
                copyButton.textContent = 'Copied!';
                setTimeout(() => {
                    copyButton.textContent = 'Copy Code';
                }, 2000);
            });
        });

        // Copy contract address button click handler
        document.getElementById('copy-contract-button').addEventListener('click', () => {
            const contractAddress = document.getElementById('contract-address').textContent;
            navigator.clipboard.writeText(contractAddress).then(() => {
                const copyButton = document.getElementById('copy-contract-button');
                copyButton.textContent = 'Copied!';
                setTimeout(() => {
                    copyButton.textContent = 'Copy Contract Address';
                }, 2000);
            });
        });

        // Redeem code button click handler
        document.getElementById('redeem-code-button').addEventListener('click', async () => {
            const codeInput = document.getElementById('redeem-code');
            const code = codeInput.value.trim();
            const redeemMessage = document.getElementById('redeem-message');
            
            if (!code) {
                redeemMessage.textContent = 'Please enter a transaction code.';
                redeemMessage.className = 'error-message';
                redeemMessage.style.display = 'block';
                return;
            }
            
            // Check if code has already been used
            if (usedCodes.has(code)) {
                redeemMessage.textContent = 'This code has already been redeemed.';
                redeemMessage.className = 'error-message';
                redeemMessage.style.display = 'block';
                return;
            }
            
            // Try to decrypt the code
            const decryptedMessage = await crypto.decrypt(code);
            
            if (decryptedMessage && decryptedMessage.startsWith('Get ')) {
                // Extract amount from message
                const amountStr = decryptedMessage.substring(4);
                const amount = parseFloat(amountStr);
                
                if (!isNaN(amount) && amount > 0) {
                    // Mark code as used
                    usedCodes.add(code);
                    
                    // Add to wallet balance
                    wallet.addBalance(amount);
                    
                    // Add transaction to history
                    wallet.addTransaction('received', amount, code);
                    
                    // Show success message
                    redeemMessage.textContent = `Successfully redeemed ${amount.toFixed(7)} EncrCoins!`;
                    redeemMessage.className = 'success-message';
                    redeemMessage.style.display = 'block';
                    
                    // Clear input
                    codeInput.value = '';
                } else {
                    redeemMessage.textContent = 'Invalid transaction code format.';
                    redeemMessage.className = 'error-message';
                    redeemMessage.style.display = 'block';
                }
            } else {
                redeemMessage.textContent = 'Invalid or expired transaction code.';
                redeemMessage.className = 'error-message';
                redeemMessage.style.display = 'block';
            }
        });

        // Update time ago every minute
        setInterval(() => {
            if (blockchain.miningStats.lastBlockTime) {
                document.getElementById('last-block-time').textContent = blockchain.formatTimeAgo(blockchain.miningStats.lastBlockTime);
            }
        }, 60000);
    </script>
</body>
</html>
